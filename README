

You may see that I have a lot of other ARM based projects at github,
I do have a lot of low level ARM experience, as well as a fair amount
with other platforms but never got into MIPS.  Have wanted to but
needed a starting place.

So this year I bought a couple of boards from Sparkfun.  The UBW32

http://www.sparkfun.com/products/8971

I bought is now retired and replaced with a newer one.  I dont know if
that is good or bad as I found PIC32MX4 tools after buying this CUI32
board

http://www.sparkfun.com/products/9645

Specifically this tool:

http://members.dslextreme.com/users/paintyourdragon/uc/ubw32/ubw32.tar.bz2

Linked to from this page:

http://www.paintyourdragon.com/uc/ubw32/index.html

Not without problems of course.  libhid-dev is apparently not supported
by Ubuntu, or at least 10.10.  10.04 does have it and I was able to
get the sources from debian/ubuntu for 10.04 and build and install
it on 10.10.  Have not tried the newer Ubuntu versions....

Building the Microchip pic32 compiler from sources was a bust, more
work than I was interested in when the current llvm and stock gcc
are so easy to come by.  I am not interested in canned libraries, and
$900 is way out of the hobby budget for such tools.

I did find that the Microchip c32 compiler is available in pre-built
32 and 64 bit Linux versions.  You have to pay to get -O2 to work.

Codesourcery is now completely Mentor Graphics, so we will see what
happens with that .  Hopefully they wont make the typical mistakes that
cause the product line and purchase of the company to be a bust for
the existing user base.

So I still have a lot to learn about MIPS and the instruction set, I
was able to get enough assembler going to boot and run some sample
programs.

These are NOT StickOS nor UBW32 programs.  These are C and/or assembly
programs that replace StickOS or UBW32.  You can always put that
firmware back on the board, so long as you dont mess up the lower
area of flash.  The xD000000 - xD005000 range of flash at a minimum
is preserved for the bootloader, between xD005000 and xD006000 is
for exception vectors or something like that and the user programs
can/should start at 0xxD006000.  Mess up the flash below 0xxD005000
and maybe you brick the board, maybe not, you have been warned.

I assume it may be crt0.o from the Mirochip tools, who knows but
the UB32 firmware .hex file used the physical addresses in the
0x1D006000+ range, but the first few instructions switched to a
0x9D006000+ range (thus the 0xxD006000 nomenclature above), so I made
my linker script cause the same to occur, executes as if it was
0x9Dxxxxxx but build a .hex file for 0x1Dxxxxxx.  Using 0x80000000
for ram goes along with the 0x9Dxxx flash and it appears to work just
fine so far.

Microchip is using little endian so -EL is used on all the gnu command
lines.  This is critical if you leave that off and get big endian
.hex files, well it wont work...

The ubw32 flash loader program did not like a type 05 entries in the
.hex file, probably a simple change in that program, which is not mine,
so I wrote a quick program that takes the binutils created .hex file
and creates another .hex file with the offending line removed.  The
ihex tool takes something.hex in and creates something.hex.hex.  The
.hex.hex file is the one you want to feed the ubw32 loader.

Codesourcery which I think is completely switched over to Mentor
Graphics now, is currently THE place for ARM based gcc tools, so I went
there to get MIPS based tools.  And that is what was used for gcc and
binutils with these examples.

I normally build the current llvm release (2.9 at the moment) as well
as a copy of the cutting edge trunk from the svn repo.  They take a
while to build, if you have a multi core processor using make -j num
makes a huge difference.  Their make file system is not perfect
so unfortunately you have to make clean if there have been changes.

LLVM is great as a cross compiler, you get all the targets in one
tool, unlike others where you have to compile a new toolchain for each
target.  Other than 32 vs 64 bit ints you can do most of your work
target independent and then the last step go from bitcode to target
specific assembler.  I use binutils assembler and linker to merge it
with startup code and other hand written assembler and take it to a
final binary.  I had some relocation problems both with gcc and llvm
using -G0 on the gnu side and -relocation-model=static or
-relocation-model=dynamic-no-pic with LLVM (llc).  As of this writing
for the blinker02 example both static and dynamic-no-pic produced the
exact same output.

Examine the makefile for more on how to use llvm
for cross compiling, at least one way to do it.  I find it best to
build all the C code, then use llvm-link to link into a single
bitcode file.  Then optimize at that point where the optimizer has
the most amount of meat to crunch on.  Then turn it into a single .s
file to feed binutils.

As of this writing there are only a couple of examples, an assembly only
example using a counter based delay, blinker01.  Blinker02 is a baseline
C based example.  Future examples will use more peripherals and get
progressively more complicated.  No desire to clone the Microchip
libraries or anything like that, take the programmers reference,
schematics and figure things out.
